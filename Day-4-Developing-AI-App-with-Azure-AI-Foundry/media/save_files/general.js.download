var detectadsbocker = true;
let ratingValue;

const validImageTypesByTool = {
    default: ["image/gif", "image/jpeg", "image/jpg", "image/png"],
    "image-to-text": [
        "image/jpeg",
        "image/jpg",
        "image/png",
        "image/gif",
        "image/bmp",
        "image/jpe",
        "image/jfif",
        "image/jfi",
        "image/jif",
        "image/tiff",
        "image/webp",
        "application/pdf",
        "image/heif",
        "image/heic",
    ],
    "jpg-to-word": [
        "image/jpeg",
        "image/jpg",
        "image/png",
        "image/gif",
        "image/bmp",
        "image/jpe",
        "image/jfif",
        "image/jfi",
        "image/jif",
        "image/tiff",
        "image/webp",
        "image/heif",
        "image/heic",
    ],
    "image-translator": [
        "image/jpeg",
        "image/jpg",
        "image/png",
        "image/gif",
        "image/bmp",
        "image/jpe",
        "image/jfif",
        "image/jfi",
        "image/jif",
        "image/tiff",
        "image/webp",
    ],
    "image-to-pdf": [
        "image/jpeg",
        "image/jpg",
        "image/png",
        "image/gif",
        "image/bmp",
        "image/jpe",
        "image/jfif",
        "image/jfi",
        "image/jif",
        "image/tiff",
        "image/webp",
        "image/heif",
        "image/heic",
    ],
    "pdf-to-text": ["application/pdf"],
    "pdf-to-word": ["application/pdf"],
    "pdf-to-jpg": ["application/pdf"],
    "word-to-pdf": [
        "application/msword",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    ],
    "merge-pdf": ["application/pdf"],
    "jpg-to-excel": [
        "image/jpeg",
        "image/jpg",
        "image/png",
        "image/webp",
        "image/heif",
        "image/heic",
        "image/tiff",
    ],
    "word-to-jpg": [
        "application/msword",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    ],
    "excel-to-jpg": [
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "application/vnd.ms-excel",
        "application/vnd.oasis.opendocument.spreadsheet",
        "application/vnd.oasis.opendocument.spreadsheet-template",
    ],
    "pdf-to-excel": [
        "application/pdf",
        "image/jpeg",
        "image/jpg",
        "image/png",
        "image/webp",
    ],
    "barcode-scanner": [
        "image/jpeg",
        "image/jpg",
        "image/png",
        "image/gif",
        "image/bmp",
        "image/jpe",
        "image/jfif",
        "image/jfi",
        "image/jif",
        "image/tiff",
        "image/webp",
        "image/heif",
        "image/heic",
        "application/pdf",
    ],
};
const mimeToExtensions = {
    "image/gif": [".gif"],
    "image/jpeg": [".jpeg", ".jpg"],
    "image/jpg": [".jpg"],
    "image/png": [".png"],
    "image/bmp": [".bmp"],
    "image/jpe": [".jpe"],
    "image/jfif": [".jfif"],
    "image/jfi": [".jfi"],
    "image/jif": [".jif"],
    "image/tiff": [".tiff"],
    "image/webp": [".webp"],
    "application/pdf": [".pdf"],
    "image/heif": [".heif"],
    "image/heic": [".heic"],
    "application/msword": [".doc", ".docx"],
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": [
        ".docx",
    ],
};
const maxFileSizeByTool = {
    default: IS_PREMIUM ? 10 : 5,
    "image-to-text": IS_PREMIUM ? 30 : 10,
};
const getMaxFileSize = (tool = "default") => {
    return maxFileSizeByTool[tool] || maxFileSizeByTool.default;
};
const setETrackKey = () => {
    let eTrackKey = localStorage.getItem("e-track-key");
    if (!eTrackKey) {
        localStorage.setItem(
            "e-track-key",
            Date.now() + Math.random().toString(36).substring(2, 22)
        );
    }
};
const getETrackKey = () => {
    return localStorage.getItem("e-track-key") || "";
};
setETrackKey();
const $stars = $(".stars button");
const showFileTypeModal = (heading, message) => {
    $("#invalidImageModal .heading").html(heading);
    $("#invalidImageModal .modal-text").html(message);
    $("#invalidImageModal").show();
};
const showNoTextModal = (heading, message) => {
    $("#invalidtextModal .heading").html(heading);
    $("#invalidtextModal .modal-text").html(message);
    $("#invalidtextModal").show();
};

function setRouteCookie(cookieName, value, days = 1) {
    let expires = new Date();
    expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
    document.cookie = `${cookieName}=${value}; path=/; expires=${expires.toUTCString()}`;
}
function getCookie(cookieName) {
    let matches = document.cookie.match(
        new RegExp(
            "(?:^|; )" +
                cookieName.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, "\\$1") +
                "=([^;]*)"
        )
    );
    return matches ? decodeURIComponent(matches[1]) : false;
}

function validateEmail(email) {
    const re =
        /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test(email);
}

const currentRoute = window.location.pathname.replace(/\//g, "_");
const cookieName = `isFeedBackSubmitted${currentRoute}`;

// Get the current route dynamically
const currentRouteCheck = window.location.pathname.replace(/\//g, "_");
const cookieCheckName = `isFeedBackSubmitted${currentRouteCheck}`;

const isFeedBackSubmitted = getCookie(cookieCheckName) || false;

$(document).ready(function () {
    $(".accountModalClose").on("click", function () {
        $("#invalidImageModal").hide();
        $("#invalidtextModal").hide();
    });
    // rating starts logic start
    $stars.hover(
        function () {
            const rating = $(this).data("count");
            highlightStars(rating);
        },
        function () {
            const $clickedStar = $(".stars button.clicked");
            const clickedRating = $clickedStar.length
                ? $clickedStar.last().data("count")
                : 0;
            highlightStars(clickedRating);
        }
    );
    // onclick star open review form popup
    $stars.on("click", function (e) {
        e.stopPropagation();
        $stars.removeClass("clicked");
        $(this).addClass("clicked");
        const rating = $(this).data("count");
        ratingValue = rating;
        highlightStars(rating);

        // Open the review form popup
        const $reviewForm = $(".review-form");
        $reviewForm.slideDown();
    });
    // hide form on outside click of doc
    $(document).on("click", (e) => {
        const $reviewForm = $(".review-form");
        const $starsButton = $(".stars button");

        // Check if the clicked element is NOT inside the review form or the stars button
        if (
            !$reviewForm.is(e.target) &&
            $reviewForm.has(e.target).length === 0 &&
            !$starsButton.is(e.target) &&
            $starsButton.has(e.target).length === 0
        ) {
            $reviewForm.slideUp();
        }
    });
    // onsubmit review form
    $(".review-form").on("submit", handleReviewForm);
    // rating stars logic end

    $(".js-toggle-pro").on("click", toggleProMode);
    $(".online-chat-li").on("click", openChat);
    $(".online-chat-nav").on("click", openChat);

    $.ajaxSetup({
        data: {
            emd_is_tool_premium: IS_TOOL_PREMIUM,
        },
    });
    setTimeout(() => {
        $(".error-alert").remove();
    }, 3000);
    $(".js-plan-option").on("change", (e) => {
        const _this = $(e.currentTarget);
        const id = _this.data("id");
        const code = _this.data("code");
        const checkoutLink = generateCheckoutLink(code, id);
        const USER_ID = $(".js-subscription-btn").data("auth-id");
        $(".js-subscription-btn").attr(
            "href",
            checkoutLink + "&x-uid=" + USER_ID
        );
        $(".js-guest-subscription-btn").attr("data-id", id);
        $(".js-guest-subscription-btn").attr("data-code", code);
    });

    $(".accountModal").on("click", (e) => {
        $(".modal").hide();
        $("#loginRegisterModal").show();
        let plan_id = $(e.currentTarget).data("id");
        let plan_code = $(e.currentTarget).data("code");
        let coupon_code = $(e.currentTarget).data("coupon") ?? "";
        $(".plan-id").val(plan_id);
        $(".plan-code").val(plan_code);
        $(".coupon-code").val(coupon_code);
        $.ajaxSetup({
            headers: {
                "X-CSRF-TOKEN": $('meta[name="_token"]').attr("content"),
            },
        });
        $.ajax({
            type: "POST",
            url: BASE_URL + "set-payment-cookie",
            data: {
                plan_id,
                plan_code,
            },
            success: function (response) {},
        });
    });

    $(".cancel-modal").on("click", (e) => {
        $("#cancelSubscriptionModal").show();
    });

    $(".accountModalClose").on("click", () => {
        $("#loginRegisterModal").hide();
        $("#limitExceedModal").hide();
        $("#limitExceedModalJPG").hide();
        $("#fileSizeExceedModal").hide();
        $("#cancelSubscriptionModal").hide();
        $("#fileTypeNotAllowPopup").hide();
        if (IS_PREMIUM_COOKIE) {
            $.ajaxSetup({
                headers: {
                    "X-CSRF-TOKEN": $('meta[name="_token"]').attr("content"),
                },
            });
            $.ajax({
                type: "POST",
                url: BASE_URL + "unset-cookies",
                success: function (response) {},
            });
        }
    });

    // window.onclick = function (event) {
    //     var modal = document.getElementById("loginRegisterModal");
    //     if (event.target == modal) {
    //         modal.style.display = "none";
    //     }
    // }

    $("#jsShowSignIn").on("click", (e) => {
        $(".showSignIn").removeClass("d-none");
        $(".showSignUp").addClass("d-none");
    });

    $("#jsShowSignUp").on("click", (e) => {
        $(".showSignIn").addClass("d-none");
        $(".showSignUp").removeClass("d-none");
    });

    $(".dropdown").on("click", (e) => {
        $(".dropdown-content").toggleClass("active");
    });

    window.addEventListener("click", (e) => {
        if (document.getElementById("dropdown")) {
            if (
                !document.getElementById("dropdown").contains(e.target) &&
                window.innerWidth > 991
            ) {
                $(".dropdown-content").removeClass("active");
            }
        }
    });
});
function generateCheckoutLink(planCode = 91113, planID = 35, coupon = null) {
    // Create the query parameters object
    const queryParams = {
        "products[1][id]": planCode,
        "page-template": 16845,
        language: "en",
        // 'currency': 'USD',
        // 'payment-method': 14,
        "x-pid": planID,
    };

    // Add the coupon if provided
    if (coupon !== null) {
        queryParams["coupon-code-to-add"] = coupon;
    }

    // Convert the query parameters object into a query string
    const queryString = new URLSearchParams(queryParams).toString();

    // Construct the full URL
    const baseLink = "https://store.payproglobal.com/checkout";
    return decodeURIComponent(`${baseLink}?${queryString}`);
}

// Example usage:
// console.log(generateCheckoutLink(12345, 67890, 'MYCOUPON2024'));

const getAllowedExtensions = (mimeTypes) => {
    const allowedExtensions = new Set();
    mimeTypes.forEach((mimeType) => {
        if (mimeToExtensions[mimeType]) {
            mimeToExtensions[mimeType].forEach((extension) =>
                allowedExtensions.add(extension)
            );
        }
    });
    return Array.from(allowedExtensions);
};
const getValidImageTypes = (tool = "default") => {
    return validImageTypesByTool[tool] || validImageTypesByTool.default;
};
const loadScriptsDynamically = (scripts) => {
    scripts.forEach((scriptInfo) => {
        const script = document.createElement("script");
        script.src = scriptInfo.src;
        script.async = true;
        script.defer = true;
        if (scriptInfo.id) {
            script.id = scriptInfo.id;
        }
        if (scriptInfo.type) {
            script.type = scriptInfo.type;
        }
        if (scriptInfo.attributes) {
            Object.keys(scriptInfo.attributes).forEach((attr) => {
                script.setAttribute(attr, scriptInfo.attributes[attr]);
            });
        }
        document.head.appendChild(script);
    });
};
const toggleProMode = () => {
    if (IS_PREMIUM) {
        $.ajaxSetup({
            headers: {
                "X-CSRF-TOKEN": $('meta[name="_token"]').attr("content"),
            },
        });
        $.ajax({
            type: "POST",
            url: BASE_URL + "toggle-pro-mode",
            success: function (response) {
                window.location.href = BASE_URL;
            },
        });
        return;
    }
};
const toggle_menubar = (e) => {
    const $dropdown = $(".mobile-nav-dropdown");
    const $closeIconTrigger = $(".navbar-icon");
    const $menuIconTrigger = $(".close-icon");
    const $viewmoeTrigger = $(".go-icon");

    $("body").css("overflow", $dropdown.hasClass("w-100") ? "auto" : "hidden");
    $dropdown.toggleClass("w-100");
    $closeIconTrigger.toggleClass("d-none");
    $menuIconTrigger.toggleClass("d-none");
    setTimeout(() => {
        $viewmoeTrigger.toggleClass("d-none");
    }, 200);
};

const startOver = (e) => {
    $(".result-span").hide();
    $(".tool-span").show();
    $(".before-upload").removeClass("d-none");
    $(".after-upload").addClass("d-none");
    if (!getValidImageTypes().includes("application/pdf")) {
        $("#img-prev").attr("src", "");
    }
    $(".file-url").val("");
    $("#file").val("");
    $(".after-loader").removeClass("d-none");
    $(".loader").addClass("d-none");
    $("#edit-tool-btns").css("display", "none");
    $("#uploads-btns").css("display", "block");
    $(".left").show();
    $(".span-start-over").hide();
    $(".js_capcha_submit_row").show();
    image = null;
    captchaToken = "";
};
const base64CheckImageExists = (base64Data, callback) => {
    var img = new Image();
    img.crossOrigin = "Anonymous";
    img.onload = function () {
        callback(true);
    };
    img.onerror = function () {
        callback(false);
    };
    img.src = base64Data;
};

const check_adblocker = (e) => {
    return false;
    if (IS_PREMIUM == 1) {
        return false;
    }
    if (env != "production") {
        return false;
    }
    if (detectadsbocker == true) {
        $(".ad_blocker").css("display", "flex");
        return true;
    } else {
        return false;
    }
};
const checkIfImageExists = (url, callback) => {
    const img = new Image();
    img.src = url;
    if (img.complete) {
        callback(true);
    } else {
        img.onload = () => {
            callback(true);
        };
        img.onerror = () => {
            callback(false);
        };
    }
};
const imageUrlToFileList = async (imageUrl) => {
    const fileList = new DataTransfer();
    let response;
    try {
        response = await fetch(imageUrl, { mode: "cors" }); // Ensure CORS mode
        if (
            !response.ok ||
            response.headers.get("content-type").includes("text/html")
        ) {
            throw new Error("Image request returned HTML instead of an image.");
        }
    } catch (e) {
        // Send request to backend (server-side workaround)
        const formData = new FormData();
        const csrfToken = $('meta[name="_token"]').attr("content");
        formData.append("imageUrl", imageUrl);
        formData.append("_token", csrfToken);
        response = await fetch(BASE_URL + "fetch-file", {
            method: "POST",
            body: formData,
        });
    }
    const blob = await response.blob();
    if (!blob.type.startsWith("image/")) {
        return null; // Exit early if it's not an image
    }
    const file = new File([blob], "image." + blob.type.split("/").pop(), {
        type: blob.type,
    });
    fileList.items.add(file);
    return [...fileList.files];
};

const convertTiffToJpgBase64 = (tiffFile) => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function (e) {
            const buffer = e.target.result;
            const tiff = new Tiff({ buffer: buffer });
            const canvas = tiff.toCanvas(0);
            const jpegCanvas = document.createElement("canvas");
            const ctx = jpegCanvas.getContext("2d");
            jpegCanvas.width = canvas.width;
            jpegCanvas.height = canvas.height;
            ctx.drawImage(canvas, 0, 0);
            const jpegBase64 = jpegCanvas.toDataURL("image/jpeg");
            resolve(jpegBase64);
        };
        reader.onerror = function (error) {
            reject(error);
        };
        reader.readAsArrayBuffer(tiffFile);
    });
};

const convertWebpFileToJpgBase64 = (webpFile) => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function (e) {
            const img = new Image();
            img.onload = function () {
                const canvas = document.createElement("canvas");
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext("2d");
                ctx.drawImage(img, 0, 0);
                const jpgBase64 = canvas.toDataURL("image/jpeg");
                resolve(jpgBase64);
            };
            img.onerror = function (error) {
                reject(error);
            };
            img.src = e.target.result;
        };
        reader.onerror = function (error) {
            reject(error);
        };
        reader.readAsDataURL(webpFile);
    });
};

const fetchAndConvertToBase64 = async (dropboxLink) => {
    try {
        // Fetch the image content from the Dropbox link
        const response = await fetch(dropboxLink);
        // Check if the response is successful (status code 200)
        if (response.ok) {
            // Read the response body as an ArrayBuffer
            const arrayBuffer = await response.arrayBuffer();
            // Convert the ArrayBuffer to a base64-encoded string
            const base64String = arrayBufferToBase64(arrayBuffer);
            return base64String;
        } else {
            // Handle HTTP error
            throw new Error(
                `HTTP Error: ${response.status} - ${response.statusText}`
            );
        }
    } catch (error) {
        // Handle network or other errors
        throw error;
    }
};
const createDocxWithImage = (base64Image, imageWidth) => {
    const content = "";
    // Calculate the maximum width based on the page width (in twips)
    const maxWidthTwips = 12240; // Assuming standard A4 paper size (8.5 x 11 inches) with default margins

    // Convert imageWidth from inches to twips
    const maxWidthPixels = maxWidthTwips / 1440; // Convert from twips to pixels

    // Calculate the image width in twips
    const imageWidthTwips = imageWidth * 1440; // Convert from inches to twips

    // Adjust the image width if it exceeds the maximum width
    const adjustedWidthTwips = Math.min(imageWidthTwips, maxWidthTwips);

    // Construct the XML for the document
    const doc = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
        <w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
            <w:body>
                <w:p>
                    <w:r>
                        <w:t>${content}</w:t>
                    </w:r>
                </w:p>
                <w:p>
                    <w:r>
                        <w:drawing>
                            <wp:inline distT="0" distB="0" distL="0" distR="0">
                                <wp:extent cx="${adjustedWidthTwips}" cy="auto"/>
                                <wp:docPr id="1" name="image"/>
                                <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">
                                    <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture">
                                        <pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">
                                            <pic:nvPicPr>
                                                <pic:cNvPr id="0" name="Image 1"/>
                                                <pic:cNvPicPr/>
                                            </pic:nvPicPr>
                                            <pic:blipFill>
                                                <a:blip r:embed="wordml://${base64Image}" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"/>
                                                <a:stretch>
                                                    <a:fillRect/>
                                                </a:stretch>
                                            </pic:blipFill>
                                            <pic:spPr>
                                                <a:xfrm>
                                                    <a:off x="0" y="0"/>
                                                    <a:ext cx="${adjustedWidthTwips}" cy="auto"/>
                                                </a:xfrm>
                                            </pic:spPr>
                                        </pic:pic>
                                    </a:graphicData>
                                </a:graphic>
                            </wp:inline>
                        </w:drawing>
                    </w:r>
                </w:p>
            </w:body>
        </w:document>`;

    // Convert the document XML to a Blob
    const blob = new Blob([doc], { type: "application/msword" });

    // Create a URL for the Blob
    const url = URL.createObjectURL(blob);

    // Create a link element
    const link = document.createElement("a");
    link.href = url;
    link.download = "document.doc"; // Change the file extension to .doc

    // Append the link to the document body and trigger the download
    document.body.appendChild(link);
    link.click();

    // Clean up by revoking the URL
    URL.revokeObjectURL(url);
};

// Function to convert an ArrayBuffer to base64
const arrayBufferToBase64 = (arrayBuffer) => {
    const binary = String.fromCharCode.apply(null, new Uint8Array(arrayBuffer));
    return btoa(binary);
};
// code to show chat on click btn
const openChat = () => {
    return;
    if (window.fcWidget.isOpen()) {
        window.fcWidget.close();
    } else {
        window.fcWidget.open();
    }
};
// code to show div on click on premium modes for free user

const promiseReadFile = (formdata) => {
    return new Promise((resolve, reject) => {
        $.ajaxSetup({
            headers: {
                "X-CSRF-TOKEN": $('meta[name="_token"]').attr("content"),
            },
        });

        $.ajax({
            url: BASE_URL + "read-file",
            type: "POST",
            data: formdata,
            contentType: false,
            processData: false,
            success: function (response) {
                try {
                    // let result = stripHtml(response) || response;
                    resolve(response); // Resolve the Promise with the result
                } catch (error) {
                    reject(error); // Reject the Promise if an error occurs
                }
            },
            error: function (xhr, textStatus, errorThrown) {
                reject(textStatus); // Reject the Promise with the error message
            },
        });
    });
};

// Function to read text from various file types and return as a Promise
const getTextFromFile = (file) => {
    // Ensure we return a Promise that resolves with the extracted text
    return new Promise((resolve, reject) => {
        if (file.type === "text/plain" || file.type === "") {
            // Plain text file
            readTextFile(file).then(resolve).catch(reject);
        } else if (file.type === "application/pdf") {
            // PDF file
            readPdfFile(file).then(resolve).catch(reject);
        } else if (
            file.type ===
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
        ) {
            // DOCX file (using Mammoth)
            readDocumentFile(file).then(resolve).catch(reject);
        } else if (file.type === "application/msword") {
            const formData = new FormData();
            formData.append("file", file);
            promiseReadFile(formData).then(resolve).catch(reject);
        } else {
            // Unsupported file type
            reject(new Error("Unsupported file type"));
        }
    });
};

// Function to read text from a plain text file
const readTextFile = (file) => {
    return new Promise((resolve, reject) => {
        var reader = new FileReader();
        reader.onload = function (event) {
            const textContent = event.target.result;
            resolve(textContent);
        };
        reader.onerror = function () {
            reject(new Error("Error reading text file"));
        };
        reader.readAsText(file);
    });
};

// Function to read text from a PDF file
const readPdfFile = (file) => {
    return new Promise((resolve, reject) => {
        var reader = new FileReader();
        reader.onload = function (event) {
            var typedarray = new Uint8Array(event.target.result);
            pdfjsLib
                .getDocument(typedarray)
                .promise.then(async (pdf) => {
                    const pagesPromises = [];
                    for (let i = 1; i <= pdf.numPages; i++) {
                        pagesPromises.push(
                            pdf.getPage(i).then((page) => {
                                return page
                                    .getTextContent()
                                    .then((textContent) => {
                                        if (0 == textContent.items.length)
                                            return "";
                                        // Sort text items by y-position, then by x-position for better layout preservation
                                        const sortedItems =
                                            textContent.items.sort((a, b) => {
                                                if (
                                                    a.transform[5] ===
                                                    b.transform[5]
                                                ) {
                                                    return (
                                                        a.transform[4] -
                                                        b.transform[4]
                                                    );
                                                }
                                                return (
                                                    b.transform[5] -
                                                    a.transform[5]
                                                );
                                            });

                                        // Rebuild lines of text based on y-coordinate proximity
                                        let lines = [];
                                        let currentLine = [];
                                        let currentY =
                                            sortedItems[0].transform[5];

                                        sortedItems.forEach((item) => {
                                            const itemY = item.transform[5];
                                            const itemX = item.transform[4];

                                            // New line if the y-position changes significantly
                                            if (
                                                Math.abs(itemY - currentY) > 5
                                            ) {
                                                lines.push(
                                                    currentLine.join(" ")
                                                );
                                                currentLine = [];
                                                currentY = itemY;
                                            }
                                            currentLine.push(item.str);
                                        });

                                        // Add the last line
                                        if (currentLine.length)
                                            lines.push(currentLine.join(" "));

                                        return lines.join("\n");
                                    });
                            })
                        );
                    }
                    // Join all pages' texts with a page separator
                    Promise.all(pagesPromises)
                        .then((pagesText) => {
                            resolve(pagesText.join("\n\n"));
                        })
                        .catch(reject);
                })
                .catch(reject);
        };
        reader.onerror = function () {
            reject(new Error("Error reading PDF file"));
        };
        reader.readAsArrayBuffer(file);
    });
};

const getPageText = (pageNum, PDFDocumentInstance) => {
    return PDFDocumentInstance.getPage(pageNum).then(function (pdfPage) {
        return pdfPage.getTextContent().then(function (textContent) {
            var textItems = textContent.items;
            var finalString = "";
            for (var i = 0; i < textItems.length; i++) {
                var item = textItems[i];
                finalString += item.str + " ";
            }

            return finalString;
        });
    });
};
// Function to extract text from a DOCX file using Mammoth
const readDocumentFile = (file) => {
    // https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js
    return new Promise((resolve, reject) => {
        var reader = new FileReader();
        reader.onload = function (event) {
            var arrayBuffer = event.target.result;
            mammoth
                .convertToHtml({ arrayBuffer: arrayBuffer })
                .then(function (result) {
                    var text = result.value; // The raw text
                    resolve(text);
                })
                .catch(function (err) {
                    reject(
                        new Error(
                            "Error extracting text from DOCX file: " + err
                        )
                    );
                });
        };
        reader.onerror = function () {
            reject(new Error("Error reading DOCX file"));
        };
        reader.readAsArrayBuffer(file);
    });
};

const generateRandomString = (length = 6) => {
    const characters =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let result = "";
    const charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
        result += characters.charAt(
            Math.floor(Math.random() * charactersLength)
        );
    }

    return result;
};

const loadScript = (src, id) => {
    return new Promise((resolve, reject) => {
        if ($("#" + id).length) {
            resolve();
            return;
        }
        const script = document.createElement("script");
        script.src = src;
        script.id = id;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
    });
};
const loadStyle = (src, id) => {
    return new Promise((resolve, reject) => {
        if ($("#" + id).length) {
            resolve();
            return;
        }
        const link = document.createElement("link");
        link.rel = "stylesheet";
        link.href = src;
        link.id = id;
        link.onload = resolve;
        link.onerror = reject;
        document.head.appendChild(link);
    });
};
const shortenTheFileName = (fileName, maxLength = 10) => {
    if (fileName.length > maxLength) {
        const lastDotIndex = fileName.lastIndexOf(".");
        const name = fileName.substring(0, maxLength);
        const ext = fileName.substring(lastDotIndex);
        return name + ext;
    }
    return fileName;
};
const convertHeicToImg = (file) => {
    return new Promise((resolve, reject) => {
        fetch(URL.createObjectURL(file))
            .then((res) => res.blob())
            .then((blob) =>
                heic2any({
                    blob,
                })
            )
            .then((conversionResult) => {
                const reader = new FileReader();
                reader.onload = function (event) {
                    const base64 = event.target.result;
                    resolve(base64);
                };
                reader.onerror = function (error) {
                    reject(error);
                };
                reader.readAsDataURL(conversionResult);
            })
            .catch((e) => {
                console.log(e);
            });
    });
};

function highlightStars(rating) {
    $stars.each(function () {
        const starRating = $(this).data("count");
        const $img = $(this).find("img");
        if (starRating <= rating) {
            $img.addClass("hover");
        } else {
            $img.removeClass("hover");
        }
    });
}
// handle review form
const handleReviewForm = async (e) => {
    e.preventDefault();
    $("#js-error-message").removeClass("review-error review-success").text("");
    const $formData = new FormData();
    let email = $(".review-form #email").val();
    let message = $(".review-form #message").val();
    if (message == "") {
        message = "---";
    }
    if (message.length < 3) {
        message += "---";
    }
    const $reviewForm = $(".review-form");

    $formData.append("rating", ratingValue);
    $formData.append("email", email);
    $formData.append("message", message);
    $formData.append("tool_id", TOOL_ID);
    $formData.append("e_track_key", getETrackKey());

    try {
        $.ajax({
            method: "POST",
            url: BASE_URL + "emd/feedback-send",
            contentType: false,
            processData: false,
            data: $formData,
            headers: {
                "X-CSRF-TOKEN": $('meta[name="_token"]').attr("content"),
            },
            success: function (response) {
                $("#js-error-message")
                    .addClass("review-success")
                    .fadeIn()
                    .text("Feedback Submitted");
                $(".submit-message").css("pointer-events", "none");
                setRouteCookie(cookieName, true, 1);
                setTimeout(() => {
                    $(".review-form #email").val("");
                    $(".review-form #message").val("");
                    $(".stars button")
                        .removeClass("clicked")
                        .find("img")
                        .removeClass("hover");
                    $reviewForm.slideUp();
                    $("#js-error-message")
                        .removeClass("review-success")
                        .text("");
                    $(".review-stars").addClass("d-none");
                    $(".submit-message").css("pointer-events", "auto");
                }, 3000);
            },
            error: function (xhr) {
                $("#js-error-message")
                    .addClass("review-error")
                    .fadeIn()
                    .text(xhr.responseJSON.message || "An error occurred.");
                setTimeout(() => {
                    $(".review-form #email").val("");
                    $(".review-form #message").val("");
                    $(".stars button")
                        .removeClass("clicked")
                        .find("img")
                        .removeClass("hover");
                    $("#js-error-message").removeClass("review-error").text("");
                }, 3000);
            },
            complete: function () {
                setTimeout(() => {
                    $(".review-form #email").val("");
                    $(".review-form #message").val("");
                    $(".stars button")
                        .removeClass("clicked")
                        .find("img")
                        .removeClass("hover");
                    $(".submit-message").css("pointer-events", "auto");
                }, 3000);
            },
        });
    } catch (error) {
        console.log("error", error);
    }
};
const base64ToFile = (base64, fileName) => {
    const arr = base64.split(",");
    const mime = arr[0].match(/:(.*?);/)[1];
    const byteString = atob(arr[1]);
    const buffer = new ArrayBuffer(byteString.length);
    const view = new DataView(buffer);

    for (let i = 0; i < byteString.length; i++) {
        view.setUint8(i, byteString.charCodeAt(i));
    }

    const blob = new Blob([buffer], { type: mime });

    return new File([blob], fileName, { type: mime });
};
$(document).on("keydown", function (event) {
    if (event.key === "Escape" || event.keyCode === 27) {
        $(".modal").hide();
        $("#lightbox").remove();
        $("#invalidImageModal").hide();
    }
});
